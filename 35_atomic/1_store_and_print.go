package main

import (
	"fmt"
	"time"
)

var x int64 = 0x3333333333333333

func storeFunc() {
	for i := 0; ; i++ {
		if i%2 == 0 {
			x = 0x1111111111111111
		} else {
			x = 0x2222222222222222
		}
		//time.Sleep(10 * time.Millisecond)
	}
}

func main() {
	go storeFunc()

	for {
		time.Sleep(1 * time.Second)
		//time.Sleep(10 * time.Millisecond)
		fmt.Printf("%x\n", x)
	}
}

// 直接变量访问指令可能不会引起内存的读取，现在编译器都会做优化，可以把变量优化到寄存器，在代码运行期间对变量的读写直接访问寄存器，而不写入内存；
// 这在同一个执行上下文是没有问题的，而如果需要跨线程访问，则永远看不到变量值的变化。下面一个例子说明这个问题：

// 这段代码：
//
//定义一个全局变量x初始值为0x333333333333
//定义一个goroutine，依次修改变量x的值为0x1111111111111111和0x2222222222222222
//在main里面，不停的读取x的值，打印出来。
//我们会看到打印出来的结果始终是：0x3333333333333333
//也就是说storeFunc的代码没有被执行到；实际上是函数storeFunc的代码编译器做了优化，对x的赋值并没有写回到内容(可能就存储在寄存器中)，而storeFunc和main是在两个goroutine里面运行的，他们并不共享CPU执行上下文，从而main读出的值永远是初始值。
//
//如果我们在storeFunc的循环内加一个sleep间隔，让x的值能够被写入内容，那么main函数就会读出0x1111111111111111和0x2222222222222222的值。

// 所有不同线程访问同一变量的时候，需要加锁，保证内存可见性。
