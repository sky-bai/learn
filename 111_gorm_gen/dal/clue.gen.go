// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"learn/111_gorm_gen/model"
)

func newClue(db *gorm.DB, opts ...gen.DOOption) clue {
	_clue := clue{}

	_clue.clueDo.UseDB(db, opts...)
	_clue.clueDo.UseModel(&model.Clue{})

	tableName := _clue.clueDo.TableName()
	_clue.ALL = field.NewAsterisk(tableName)
	_clue.ID = field.NewInt64(tableName, "id")
	_clue.CreatedAt = field.NewTime(tableName, "created_at")
	_clue.UpdatedAt = field.NewTime(tableName, "updated_at")
	_clue.DeletedAt = field.NewField(tableName, "deleted_at")
	_clue.Message = field.NewString(tableName, "message")
	_clue.AccidentType = field.NewString(tableName, "accident_type")
	_clue.URL = field.NewString(tableName, "url")
	_clue.CrashLevel = field.NewString(tableName, "crash_level")
	_clue.Distance = field.NewFloat64(tableName, "distance")
	_clue.AccidentAt = field.NewTime(tableName, "accident_at")
	_clue.Longitude = field.NewFloat64(tableName, "longitude")
	_clue.Latitude = field.NewFloat64(tableName, "latitude")
	_clue.RecorderImei = field.NewString(tableName, "recorder_imei")
	_clue.LocationAccident = field.NewString(tableName, "location_accident")
	_clue.Status = field.NewInt32(tableName, "status")
	_clue.AccountID = field.NewInt64(tableName, "account_id")
	_clue.EnterpriseID = field.NewInt64(tableName, "enterprise_id")
	_clue.SubsidiaryID = field.NewInt64(tableName, "subsidiary_id")
	_clue.UpdatedByID = field.NewInt64(tableName, "updated_by_id")
	_clue.CarOwnerRegister = field.NewBool(tableName, "car_owner_register")

	_clue.fillFieldMap()

	return _clue
}

type clue struct {
	clueDo

	ALL              field.Asterisk
	ID               field.Int64   // 主键Id
	CreatedAt        field.Time    // 创建时间
	UpdatedAt        field.Time    // 修改时间
	DeletedAt        field.Field   // 删除时间
	Message          field.String  // 线索信息
	AccidentType     field.String  // 事故类型
	URL              field.String  // 事故视频url
	CrashLevel       field.String  // 碰撞等级
	Distance         field.Float64 // 距离4s店的距离
	AccidentAt       field.Time    // 事故触发时间
	Longitude        field.Float64 // 事故发生时的经度
	Latitude         field.Float64 // 事故发生时的纬度
	RecorderImei     field.String  // 记录仪的imei号
	LocationAccident field.String  // 事故发生时的地点
	Status           field.Int32   // 线索当前状态 新线索默认待处理1，跟进中2，有效3，无效4
	AccountID        field.Int64   // 操作人ID
	EnterpriseID     field.Int64   // 集团id
	SubsidiaryID     field.Int64   // 店铺id
	UpdatedByID      field.Int64   // 操作账号Id
	CarOwnerRegister field.Bool    // 车主端是否注册

	fieldMap map[string]field.Expr
}

func (c clue) Table(newTableName string) *clue {
	c.clueDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c clue) As(alias string) *clue {
	c.clueDo.DO = *(c.clueDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *clue) updateTableName(table string) *clue {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewInt64(table, "id")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.DeletedAt = field.NewField(table, "deleted_at")
	c.Message = field.NewString(table, "message")
	c.AccidentType = field.NewString(table, "accident_type")
	c.URL = field.NewString(table, "url")
	c.CrashLevel = field.NewString(table, "crash_level")
	c.Distance = field.NewFloat64(table, "distance")
	c.AccidentAt = field.NewTime(table, "accident_at")
	c.Longitude = field.NewFloat64(table, "longitude")
	c.Latitude = field.NewFloat64(table, "latitude")
	c.RecorderImei = field.NewString(table, "recorder_imei")
	c.LocationAccident = field.NewString(table, "location_accident")
	c.Status = field.NewInt32(table, "status")
	c.AccountID = field.NewInt64(table, "account_id")
	c.EnterpriseID = field.NewInt64(table, "enterprise_id")
	c.SubsidiaryID = field.NewInt64(table, "subsidiary_id")
	c.UpdatedByID = field.NewInt64(table, "updated_by_id")
	c.CarOwnerRegister = field.NewBool(table, "car_owner_register")

	c.fillFieldMap()

	return c
}

func (c *clue) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *clue) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 20)
	c.fieldMap["id"] = c.ID
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["deleted_at"] = c.DeletedAt
	c.fieldMap["message"] = c.Message
	c.fieldMap["accident_type"] = c.AccidentType
	c.fieldMap["url"] = c.URL
	c.fieldMap["crash_level"] = c.CrashLevel
	c.fieldMap["distance"] = c.Distance
	c.fieldMap["accident_at"] = c.AccidentAt
	c.fieldMap["longitude"] = c.Longitude
	c.fieldMap["latitude"] = c.Latitude
	c.fieldMap["recorder_imei"] = c.RecorderImei
	c.fieldMap["location_accident"] = c.LocationAccident
	c.fieldMap["status"] = c.Status
	c.fieldMap["account_id"] = c.AccountID
	c.fieldMap["enterprise_id"] = c.EnterpriseID
	c.fieldMap["subsidiary_id"] = c.SubsidiaryID
	c.fieldMap["updated_by_id"] = c.UpdatedByID
	c.fieldMap["car_owner_register"] = c.CarOwnerRegister
}

func (c clue) clone(db *gorm.DB) clue {
	c.clueDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c clue) replaceDB(db *gorm.DB) clue {
	c.clueDo.ReplaceDB(db)
	return c
}

type clueDo struct{ gen.DO }

type IClueDo interface {
	gen.SubQuery
	Debug() IClueDo
	WithContext(ctx context.Context) IClueDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IClueDo
	WriteDB() IClueDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IClueDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IClueDo
	Not(conds ...gen.Condition) IClueDo
	Or(conds ...gen.Condition) IClueDo
	Select(conds ...field.Expr) IClueDo
	Where(conds ...gen.Condition) IClueDo
	Order(conds ...field.Expr) IClueDo
	Distinct(cols ...field.Expr) IClueDo
	Omit(cols ...field.Expr) IClueDo
	Join(table schema.Tabler, on ...field.Expr) IClueDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IClueDo
	RightJoin(table schema.Tabler, on ...field.Expr) IClueDo
	Group(cols ...field.Expr) IClueDo
	Having(conds ...gen.Condition) IClueDo
	Limit(limit int) IClueDo
	Offset(offset int) IClueDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IClueDo
	Unscoped() IClueDo
	Create(values ...*model.Clue) error
	CreateInBatches(values []*model.Clue, batchSize int) error
	Save(values ...*model.Clue) error
	First() (*model.Clue, error)
	Take() (*model.Clue, error)
	Last() (*model.Clue, error)
	Find() ([]*model.Clue, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Clue, err error)
	FindInBatches(result *[]*model.Clue, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Clue) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IClueDo
	Assign(attrs ...field.AssignExpr) IClueDo
	Joins(fields ...field.RelationField) IClueDo
	Preload(fields ...field.RelationField) IClueDo
	FirstOrInit() (*model.Clue, error)
	FirstOrCreate() (*model.Clue, error)
	FindByPage(offset int, limit int) (result []*model.Clue, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IClueDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c clueDo) Debug() IClueDo {
	return c.withDO(c.DO.Debug())
}

func (c clueDo) WithContext(ctx context.Context) IClueDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c clueDo) ReadDB() IClueDo {
	return c.Clauses(dbresolver.Read)
}

func (c clueDo) WriteDB() IClueDo {
	return c.Clauses(dbresolver.Write)
}

func (c clueDo) Session(config *gorm.Session) IClueDo {
	return c.withDO(c.DO.Session(config))
}

func (c clueDo) Clauses(conds ...clause.Expression) IClueDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c clueDo) Returning(value interface{}, columns ...string) IClueDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c clueDo) Not(conds ...gen.Condition) IClueDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c clueDo) Or(conds ...gen.Condition) IClueDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c clueDo) Select(conds ...field.Expr) IClueDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c clueDo) Where(conds ...gen.Condition) IClueDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c clueDo) Order(conds ...field.Expr) IClueDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c clueDo) Distinct(cols ...field.Expr) IClueDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c clueDo) Omit(cols ...field.Expr) IClueDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c clueDo) Join(table schema.Tabler, on ...field.Expr) IClueDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c clueDo) LeftJoin(table schema.Tabler, on ...field.Expr) IClueDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c clueDo) RightJoin(table schema.Tabler, on ...field.Expr) IClueDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c clueDo) Group(cols ...field.Expr) IClueDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c clueDo) Having(conds ...gen.Condition) IClueDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c clueDo) Limit(limit int) IClueDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c clueDo) Offset(offset int) IClueDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c clueDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IClueDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c clueDo) Unscoped() IClueDo {
	return c.withDO(c.DO.Unscoped())
}

func (c clueDo) Create(values ...*model.Clue) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c clueDo) CreateInBatches(values []*model.Clue, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c clueDo) Save(values ...*model.Clue) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c clueDo) First() (*model.Clue, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Clue), nil
	}
}

func (c clueDo) Take() (*model.Clue, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Clue), nil
	}
}

func (c clueDo) Last() (*model.Clue, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Clue), nil
	}
}

func (c clueDo) Find() ([]*model.Clue, error) {
	result, err := c.DO.Find()
	return result.([]*model.Clue), err
}

func (c clueDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Clue, err error) {
	buf := make([]*model.Clue, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c clueDo) FindInBatches(result *[]*model.Clue, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c clueDo) Attrs(attrs ...field.AssignExpr) IClueDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c clueDo) Assign(attrs ...field.AssignExpr) IClueDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c clueDo) Joins(fields ...field.RelationField) IClueDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c clueDo) Preload(fields ...field.RelationField) IClueDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c clueDo) FirstOrInit() (*model.Clue, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Clue), nil
	}
}

func (c clueDo) FirstOrCreate() (*model.Clue, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Clue), nil
	}
}

func (c clueDo) FindByPage(offset int, limit int) (result []*model.Clue, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c clueDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c clueDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c clueDo) Delete(models ...*model.Clue) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *clueDo) withDO(do gen.Dao) *clueDo {
	c.DO = *do.(*gen.DO)
	return c
}
