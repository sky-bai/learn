1.最初的时候是一个链接一个协程，一个请求一个协程，出现的场景是hold不住高并发，大量链接过来之后，请求耗时较长。
2.建立8个二级队列将请求放入队列中，然后协程从队列中取出请求进行处理，出现的场景是cpu利用率不高，并发上不去，然后消息无序，涉及到大量的io，rpc操作，链接的请求会相互影响，因为一个队列里面有多个链接的请求，如果第一个请求io，rpc耗时长就会影响下一个请求。
3.一开始根据服务器配置建立该服务器可以容量的链接数，并直接启动对应数量的协程，好处就是可以hold高并发，不会无休止的创建协程，链接之前的请求不相互影响。如何分配协程，创建一个map，forRange取k，然后value用struct填充标识该协程已被链接使用。

为此进行服务的监控，搭建prometheus和grafana组件，在代码中加入prometheus的监控指标，然后在grafana中进行展示。分析应用的连接数，协程数，请求耗时和内存使用率

先搭监控，后调优.

当服务器处理不过来的时候协程就会堆积。 所以不能不加限制的开辟协程。

在Linux服务器上对TCP应用进行调优可以改善网络性能和吞吐量。以下是一些常见的TCP调优方法：

1. 调整TCP内核参数：通过修改TCP内核参数可以优化TCP协议的行为。一些常见的参数包括：tcp_max_syn_backlog（设置SYN队列的最大长度）、tcp_syncookies（启用SYN
   cookies防止SYN洪水攻击）、tcp_fin_timeout（设置TCP连接关闭后等待FIN包的超时时间）等。

2. 调整TCP缓冲区大小：适当增加TCP缓冲区的大小可以提高网络吞吐量。可以通过修改参数tcp_rmem和tcp_wmem来调整接收和发送缓冲区的大小。

3. 开启TCP快速打开（TCP Fast Open）：TCP Fast Open允许在握手阶段传输数据，减少延迟。可以通过设置参数tcp_fastopen来启用TCP
   Fast Open功能。

4. 开启TCP拥塞控制算法：Linux支持多种TCP拥塞控制算法，如Cubic、BBR等。选择适合网络环境的拥塞控制算法可以提高性能。可以通过修改参数tcp_congestion_control来切换拥塞控制算法。

5. 禁用TCP延迟确认（TCP Delayed
   Acknowledgment）：禁用延迟确认可以减少延迟，特别是对于小数据包的应用。可以通过修改参数net.ipv4.tcp_sack和net.ipv4.tcp_dsack来禁用延迟确认。

6.

优化TCP超时和重传：适当调整TCP的超时和重传机制可以提高性能。可以通过修改参数net.ipv4.tcp_retries1、net.ipv4.tcp_retries2和net.ipv4.tcp_syn_retries来调整重传和SYN重传的次数。

7. 开启TCP窗口缩放（TCP Window Scaling）：TCP窗口缩放可以增加TCP窗口的大小，提高传输性能。可以通过设置参数net.ipv4.tcp_window_scaling来启用TCP窗口缩放功能。

8. 优化网络设备：确保服务器的网络设备（网卡、交换机等）正常工作，并根据实际情况进行配置和调优。

这些是一些常见的TCP应用调优方法，具体的调优策略应该根据具体的网络环境和应用需求进行调整。在进行任何调优之前，建议先备份相关的配置文件，并逐步测试和评估每个调优项的效果。

接下来我们就需要给Zinx添加消息队列和多任务Worker机制了。我们可以通过worker的数量来限定处理业务的固定goroutine数量，而不是无限制的开辟Goroutine，
虽然我们知道go的调度算法已经做的很极致了，但是大数量的Goroutine依然会带来一些不必要的环境切换成本，这些本应该是服务器应该节省掉的成本。我们可以用消息队列来缓冲worker工作的数据。

```go

```

问题场景：CPU使用率过高、内存占用不断增大（疑似泄露）、临时内存大量申请后长时间不下降，抑或是goroutine泄露、goroutine数量暴涨

还有就是mysql优化，什么时候会出现临时表



该协程是由那一段代码进行创建， 该协程的生命周期是什么样的，它的开销是多少，删除的开销是多少