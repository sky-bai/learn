package main

// 2_runtime.systemstack的内存泄漏是怎么回事
// 是因为defer错误的用在dead-loop中。 实际上defer是在函数退出前才执行的，在for循环中使用defer，函数不退出，defer就 会一直压栈，导致栈内存一直增长。

// 在 Go 应用程序的性能分析中，2_runtime.systemstack 函数的高占比表示大量的 CPU 时间花费在运行系统级任务上，而不是应用程序的逻辑代码上。2_runtime.systemstack 函数是 Go 运行时系统用于执行一些底层操作和调度任务的函数。
//
//通常情况下，2_runtime.systemstack 函数占比过高可能有以下几个原因：
//
//1. 阻塞操作：如果应用程序中存在阻塞操作，比如网络请求、文件读写等，这些操作可能会导致运行时系统需要执行一些额外的系统级任务。如果阻塞操作频繁或耗时长，就会导致 2_runtime.systemstack 函数的占比增加。
//
//2. 大量的 Goroutine 切换：如果应用程序中创建了大量的 Goroutine，并且这些 Goroutine 之间频繁切换，也会增加 2_runtime.systemstack 函数的占比。Goroutine 的切换需要运行时系统进行调度和管理，因此会增加系统级任务的执行时间。
//
//3. 调度延迟：如果应用程序中存在长时间运行的任务或者某些 Goroutine 一直没有得到执行的机会，可能会导致调度延迟。运行时系统会不断检查 Goroutine 的状态并进行调度，这些检查和调度的过程也会增加 2_runtime.systemstack 函数的占比。
//
//针对以上问题，可以考虑一些优化策略：
//
//1. 减少阻塞操作：优化应用程序中的阻塞操作，如使用异步操作、缓存等手段来降低对系统级任务的依赖。
//
//2. 减少 Goroutine 切换：评估应用程序中 Goroutine 的创建和切换频率，尽量减少不必要的 Goroutine 切换。可以通过使用连接池、批量处理等方式来优化并发操作。
//
//3. 优化调度机制：检查长时间运行的任务是否可以进行拆分或异步处理，减少调度延迟。另外，可以调整 Goroutine 的数量、调度器的参数等来优化调度性能。
//
//使用火焰图工具可以帮助定位性能瓶颈所在，更深入的分析可能需要结合具体的代码和应用场景来进行。
